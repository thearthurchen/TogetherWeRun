// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;


import '@openzeppelin/contracts/access/Ownable.sol';
import "@openzeppelin/contracts/utils/Counters.sol";
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/payment/escrow/RefundEscrow.sol';
import './Pact.sol';


contract BetterTogetherGateway is Ownable {

    // Use SafeMath because its safe
    using SafeMath for uint256;
    // Use counter to track all ids
    using Counters for Counters.Counter;

    event PactCreated(
        address host,
        uint256 id
    );

    // Track the pacts we have
    Pact[] public pacts;
    Counters.Counter private _numOfPacts;
    // Track the originator to their escrow
    mapping (address => uint256) private _originatorToEscrowIndex;
    // Achieve 1 goal at a time
    mapping (address => bool) private _host;

    //@dev Wallet to hold all the money for these pacts
    //We try our best to make sure that no one can withdraw more than they put in
    //This is probably cheaper than deploying an actual contract
    address payable wallet;

    // @dev borrowed from
    // https://medium.com/@ethdapp/using-the-openzeppelin-escrow-library-6384f22caa99
    constructor(address payable _wallet) public {
        wallet = _wallet;
        // We want all new contracts from this gateway to start at 1
        Pact dummy = new Pact(wallet, msg.sender, _numOfPacts.current());
        pacts.push(dummy);
        _numOfPacts.increment();
    }
    
    // @dev helper function to just get the contract index and make sure that it exists
    // All contracts will start at >= 1
    function _getPact(address a) internal view returns (Pact) {
        uint256 contractIndex = _originatorToEscrowIndex[a];
        require(contractIndex > 0, "Your friend doesn't want to be better together");
        return pacts[contractIndex];
    }

    function _compareStringsByBytes(string memory s1, string memory s2) internal pure returns(bool){
        return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));
    }
    
    // @dev We take the msg.sender and create a goal for them
    // Check to make sure they are not currently an originator for being better together movement
    // If they are not hosting we return the invite code for their goal
    function weAreBetterTogether() external {
        require(_originatorToEscrowIndex[msg.sender] == 0, "You already have a pact!");
        Pact pact = new Pact(wallet, msg.sender, _numOfPacts.current());
        pact.transferOwnership(msg.sender);
        pacts.push(pact);
        _originatorToEscrowIndex[msg.sender] = _numOfPacts.current();
        _numOfPacts.increment();
        emit PactCreated(msg.sender, pact.id());
    }

    function getMyPact() external view returns (address) {
        Pact pact = _getPact(msg.sender);
        return address(pact);
    }

    // @dev take the settings
    function setPactConditions(uint256 pledge, uint64 endDate, uint64 checkpointThreshold) external {
        Pact pact = _getPact(msg.sender);
        pact.setConditions(msg.sender, pledge, endDate, checkpointThreshold);
    }

    // @dev gets sender's contract invite (generated by VRF) embedded into goal
    function getInviteCode() external view returns (string memory) {
        Pact pact = _getPact(msg.sender);
        return pact.inviteCode();
    }

    // @dev given an invite code register the sender to that contract
    function beBetterTogether(string memory invite, address referrer) external {
        Pact pact = _getPact(referrer);
        require(_compareStringsByBytes(pact.inviteCode(), invite), "You're friend gave you the wrong invite!");
        pact.makePledge();
        // Register the address to that escrow too here and in the contract
        _originatorToEscrowIndex[msg.sender] = pact.id();
        // Add the address to pact
        pact.addParticipant(msg.sender);
    }

    // TODO check the progress
    function getProgress() public view returns (bool) {
        return true;
    }

    // This is just to debug stuff
    // If we invoke a method on pact, and we try to use msg.sender inside that method
    // The msg.sender is not the person who c alled this method from the gateway
    // The msg.sender pact.foo sees is the owner of this contract
    // Therefore in any method where you want the msg.sender for gateway to be passed
    // to the pact's method, we probably have to pass it in through a param
    // TODO is there anyway to bind it? I guess not because this would cost gas on behalf of the requester?
    // Maybe we should just return the address from gateway and have the owner call that contract
    function foo() public view returns (address, address, address) {
        Pact pact = _getPact(msg.sender);
        return pact.foo(msg.sender);
    }
}
